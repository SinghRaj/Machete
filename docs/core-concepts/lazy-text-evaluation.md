# Lazy Text Evaluation

To understand Lazy Text Evaluation, let's walk through a common task performed, perhaps, millions of times per day. Imagine if you were courier tasked with delivering a package to a particular house located somewhere within an area spanning multiple cities. What would be your? Would you go city by city, block by block, house by house in order to find the one you are looking for? Well, if you did go city to city, block by block, house by house there is no doubt you'd eventually accomplish your goal. That said, it wouldn't be the most efficient way of performing said task. The most efficient way, however, would be to require and enforce that each package have a shipping address prior to attempting delivery so that you can use your groovy GPS device to find the exact location. It would also, perhaps, make sense that the package come with some instructions on how best to handle its contents upon receipt.

Now apply this same logic to the problem at hand, that is, querying a document structure looking for a particular data field. Think about how inefficient it would be to randomly scan a document structure looking for a particular data field when the structure of said document is known upfront. Unfortunately, most modern parsers walk the document structure in search for matches. We found this to be both tedious and strange considering how the human mind works. Think about how one would query a relational database. Since as far back as the 1970's, the world is very familiar with using Structured Query Language--better know as SQL--to query relational databases in search of specific data. Machete's genius is that it treats structured documents in much the same way as relational databases treat relational data, that is, it enables queries to be executed against a predefined schema in the most efficient manner possible, which is lazily.

More on how Lazy Text Evaluation fits in to parsing.

Think about how relational databases work for a second; you write a query, the database engine optimizes your query by way of creating an execution plan, and then your query is executed. So, what do you think the database engine would do in light of you not designing your table structure correctly and not using built in optimizations like indexes? Well, in this case the database engine would have no choice but to scan the specified tables looking for your data. This works, but, is very inefficient. But, what if database engine had a cheatsheet that it could use to store references to the data so that it could more easily orient itself when executing the query plan. This would, indeed, be much more efficient because it could now skip over the minutia that is everything it is not looking for. It's actually how the brain works. Don't believe me, I'll prove it. Look at the below diagram find the 

When you execute a query against a relational database, the database engine will generate a execution plan so that it takes the most efficient path to executing the query. Machete's parsing engine functions in a similar manner. Once the execution plan has been provided \(see _**figure 1**_\), the parser will orient itself within the document structure, extract the data from the specified fields and parse them into a set of predefined entities per the object mapper. As a result, Machete is said to parse data lazily. _Lazy Text Evaluation_, aka _lazy parsing_, is the primary reason why Machete's parsing engine is so fast.![](/assets/LazyTextEvaluation1.png)**Figure 1**

Lazy Text Evaluation describes the process of of applying mapping rules to text during query execution. Correlating this back to the analogy,

![](/assets/MacheteParsingEngine.png)

To be clear, calling the _Parse_ method does not actually parse the document structure in the way you might think. It is minimalistic in that only the boundaries \(i.e. end of line\) of the entity are discovered initially. That said, you'll see that calling _Parse_ returns an _EntityResult_ rather than an actual parsed object structure. There is a reason for this, that is, we haven't told the parser what exactly we would like it to parse yet. Remember, parsing in Machete is done lazily, therefore, the entity maps are not actually called when the _Parse_ method is called. Once a query is performed against the document structure, only then are entity maps called to convert the parsed text into entities.

![](/assets/LazyParsing.png)

